package io.jenkins.plugins.slurm;

import com.michelin.cio.hudson.plugins.copytoslave.CopyToSlaveBuildWrapper;
import com.michelin.cio.hudson.plugins.copytoslave.CopyToMasterNotifier;
import hudson.AbortException;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.AbstractBuild;
import hudson.model.AbstractProject;
import hudson.model.BuildListener;
import hudson.model.Computer;
import hudson.model.Node;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.tasks.ArtifactArchiver;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Builder;
import hudson.util.FormValidation;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.StringBuffer;
import java.util.Scanner;
import jenkins.tasks.SimpleBuildStep;
import org.jenkinsci.Symbol;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.DataBoundConstructor;

public class SLURMBuilder extends BatchBuilder {
    
    @DataBoundConstructor
    public SLURMBuilder(String rawScript, int nodes, int processesPerNode,
            int walltime, String queue, boolean exclusive, 
            NotificationConfig notificationConfig,
            String outFileName, String errFileName) {
        super(rawScript,nodes,processesPerNode,walltime,queue,exclusive,
                notificationConfig,outFileName,errFileName);
    }
    
    @Override
    public void perform(Run<?,?> run, FilePath workspace, Launcher launcher, 
            TaskListener listener) throws InterruptedException, IOException {
        Computer computer = getComputer(workspace);
        Node node = getNode(computer);
        try { //TODO - remove this later, only a debug thing
            listener.getLogger().println(computer.getNode().getDisplayName());
        } catch (NullPointerException e) {
            listener.getLogger().println("WARNING: No display name found for node");
        }
        if (!(computer instanceof SLURMSlaveComputer)) {
            throw new AbortException("Computer is not a SLURM node computer");
        }
        SLURMSlave slurmNode = (SLURMSlave) node;
        String finalScript = generateScript(rawScript,slurmNode,listener);
        listener.getLogger().print(finalScript);
        String jobFileName = "script"; //TODO - figure out naming convention
        writeScriptToFile(finalScript,jobFileName);
        listener.getLogger().println("Remote: "+workspace.getRemote());
        sendFileToRemote(jobFileName,run,workspace,launcher,listener);
        listener.getLogger().println("Script sent to remote node");
        BatchSystem batchSystem = new SLURMSystem(run,workspace,launcher,listener);
        batchSystem.submitJob(jobFileName); //TODO - make waitFor() clearer
        listener.getLogger().println("Recovering files from slave");
        String filesToRecover = "comms.txt";
        if (outFileName != null && outFileName.length()>0) {
            filesToRecover += ","+outFileName;
        }
        if (errFileName != null && errFileName.length()>0) {
            filesToRecover += ","+errFileName;
        }
        String recoveryDestination=run.getRootDir().getAbsolutePath();
        listener.getLogger().println("Recovery destination: "+recoveryDestination);
        recoverFiles(filesToRecover,recoveryDestination,run,workspace,launcher,listener);
    }
    
    
    public String generateScript(String rawScript, SLURMSlave node, TaskListener listener) throws AbortException {
        String prefix = node.getPrefix();
        String filteredScript = filterScript(rawScript,prefix);
        if (filteredScript.trim().length()==0) {
            throw new AbortException("Script has no valid content");
        }
        if (!isConfigurationValid(node,listener)) {
            throw new AbortException("Configuration is invalid");
        }
        String formattedBatchOptions = node.formatBatchOptions(
                nodes, processesPerNode,walltime, queue, exclusive, 
                notificationConfig, outFileName, errFileName);
        String finalScript = "#!/bin/bash +x\n"
                            + "Script automatically generated by SLURM Plugin"
                            + formattedBatchOptions
                            + filteredScript
                            + "echo \"output\" > " + outFileName + "\n"
                            + "echo \"error\" > " + errFileName + "\n"
                            + "#End of automatically generated script";
        return finalScript;
    }
    
    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }
    
    @Symbol("submitSLURMJob")
    @Extension
    public static class DescriptorImpl extends BuildStepDescriptor<Builder> {
        @Override
        public String getDisplayName() {
            return "Run SLURM script";
        }
        
        @Override
        public boolean isApplicable(Class<? extends AbstractProject> type) {
            return true;
        }
        
        //public FormValidation doCheckField(@QueryParameter String value) {
         //   if (value.isGood()) return FormValidation.ok();
          //  else return FormValidation.error(Messaaaaaaages.xx.y.z());
        //}
        
        public FormValidation doCheckNodes(@QueryParameter int value) {
            if (value >= 1) 
                return FormValidation.ok();
            else
                return FormValidation.error(Messages.errors_NotPositiveInteger());
        }
        
        public FormValidation doCheckProcessesPerNode(@QueryParameter int value) {
            if (value >= 1) 
                return FormValidation.ok();
            else
                return FormValidation.error(Messages.errors_NotPositiveInteger());
        }
        
        
        public FormValidation doCheckWalltime(@QueryParameter int value) {
            if (value >= 1) 
                return FormValidation.ok();
            else
                return FormValidation.error(Messages.errors_NotPositiveInteger());
        }       
    }
}